Q2. 
```
Customer => (cust_id, cust_name, mobno, email, city) 
Order => (order_id, product_type, delivery_date, status, amtpaid, cust_id)

Create two tables as per given structure and execute followings.

a. Add new column to customer called 'state'.
b. Display the total amount paid by each customer.
C. Write a Trigger based on delete operation on Order table.
d. Display cust_ids of those who haven't placed any order.
```

Complete Solution for Customer-Order Database

1. Create Tables with Given Structure

```sql
-- Create Database
CREATE DATABASE customer_order_db;
USE customer_order_db;

-- Create Customer table
CREATE TABLE Customer (
    cust_id INT PRIMARY KEY AUTO_INCREMENT,
    cust_name VARCHAR(100) NOT NULL,
    mobno VARCHAR(15),
    email VARCHAR(100),
    city VARCHAR(50)
);

-- Create Order table
CREATE TABLE `Order` (
    order_id INT PRIMARY KEY AUTO_INCREMENT,
    product_type VARCHAR(50),
    delivery_date DATE,
    status VARCHAR(20),
    amtpaid DECIMAL(10,2),
    cust_id INT,
    FOREIGN KEY (cust_id) REFERENCES Customer(cust_id) ON DELETE CASCADE
);

-- Insert sample data into Customer table
INSERT INTO Customer (cust_name, mobno, email, city) VALUES
('John Smith', '9876543210', 'john@email.com', 'Mumbai'),
('Alice Johnson', '8765432109', 'alice@email.com', 'Delhi'),
('Bob Williams', '7654321098', 'bob@email.com', 'Bangalore'),
('Emma Davis', '6543210987', 'emma@email.com', 'Mumbai'),
('Mike Wilson', '5432109876', 'mike@email.com', 'Chennai'),
('Sarah Brown', '4321098765', 'sarah@email.com', 'Delhi'),
('David Lee', '3210987654', 'david@email.com', 'Pune');

-- Insert sample data into Order table
INSERT INTO `Order` (product_type, delivery_date, status, amtpaid, cust_id) VALUES
('Electronics', '2024-03-15', 'Delivered', 15000.00, 1),
('Clothing', '2024-03-18', 'Processing', 5000.00, 1),
('Books', '2024-03-20', 'Shipped', 2500.00, 2),
('Electronics', '2024-03-22', 'Delivered', 30000.00, 3),
('Home Appliances', '2024-03-25', 'Processing', 18000.00, 3),
('Clothing', '2024-03-10', 'Delivered', 7500.00, 4),
('Books', '2024-03-12', 'Cancelled', 1200.00, 4),
('Electronics', '2024-03-28', 'Shipped', 42000.00, 4);
-- Note: Customers 5, 6, 7 have not placed any orders
```

2. Solution for Each Requirement

a. Add new column to customer called 'state'

```sql
-- Add 'state' column to Customer table
ALTER TABLE Customer 
ADD COLUMN state VARCHAR(50);

-- Update existing records with state values
UPDATE Customer SET state = 'Maharashtra' WHERE city IN ('Mumbai', 'Pune');
UPDATE Customer SET state = 'Delhi' WHERE city = 'Delhi';
UPDATE Customer SET state = 'Karnataka' WHERE city = 'Bangalore';
UPDATE Customer SET state = 'Tamil Nadu' WHERE city = 'Chennai';

-- Verify the new column
SELECT cust_id, cust_name, city, state FROM Customer;

-- Sample output after adding state:
-- +---------+--------------+-----------+------------+
-- | cust_id | cust_name    | city      | state      |
-- +---------+--------------+-----------+------------+
-- |       1 | John Smith   | Mumbai    | Maharashtra|
-- |       2 | Alice Johnson| Delhi     | Delhi      |
-- |       3 | Bob Williams | Bangalore | Karnataka  |
-- |       4 | Emma Davis   | Mumbai    | Maharashtra|
-- |       5 | Mike Wilson  | Chennai   | Tamil Nadu |
-- |       6 | Sarah Brown  | Delhi     | Delhi      |
-- |       7 | David Lee    | Pune      | Maharashtra|
-- +---------+--------------+-----------+------------+
```

b. Display the total amount paid by each customer

```sql
-- Solution 1: Using LEFT JOIN to include customers with no orders
SELECT 
    c.cust_id,
    c.cust_name,
    COALESCE(SUM(o.amtpaid), 0) AS total_amount_paid
FROM Customer c
LEFT JOIN `Order` o ON c.cust_id = o.cust_id
GROUP BY c.cust_id, c.cust_name
ORDER BY total_amount_paid DESC;

-- Solution 2: Using subquery for better readability
SELECT 
    c.cust_id,
    c.cust_name,
    (SELECT COALESCE(SUM(amtpaid), 0) 
     FROM `Order` o 
     WHERE o.cust_id = c.cust_id) AS total_amount_paid
FROM Customer c
ORDER BY total_amount_paid DESC;

-- Solution 3: With additional customer details
SELECT 
    c.cust_id,
    c.cust_name,
    c.city,
    c.state,
    COUNT(o.order_id) AS total_orders,
    COALESCE(SUM(o.amtpaid), 0) AS total_amount_paid,
    COALESCE(AVG(o.amtpaid), 0) AS avg_order_value
FROM Customer c
LEFT JOIN `Order` o ON c.cust_id = o.cust_id
GROUP BY c.cust_id, c.cust_name, c.city, c.state
ORDER BY total_amount_paid DESC;

-- Expected output:
-- +---------+--------------+---------------+-----------------+
-- | cust_id | cust_name    | total_orders  | total_amount_paid|
-- +---------+--------------+---------------+-----------------+
-- |       4 | Emma Davis   |             3 |         50700.00|
-- |       3 | Bob Williams |             2 |         48000.00|
-- |       1 | John Smith   |             2 |         20000.00|
-- |       2 | Alice Johnson|             1 |          2500.00|
-- |       5 | Mike Wilson  |             0 |             0.00|
-- |       6 | Sarah Brown  |             0 |             0.00|
-- |       7 | David Lee    |             0 |             0.00|
-- +---------+--------------+---------------+-----------------+
```

c. Write a Trigger based on delete operation on Order table

```sql
-- First, create an audit table to track deleted orders
CREATE TABLE Order_Delete_Audit (
    audit_id INT PRIMARY KEY AUTO_INCREMENT,
    deleted_order_id INT,
    deleted_cust_id INT,
    deleted_product_type VARCHAR(50),
    deleted_amtpaid DECIMAL(10,2),
    deleted_date DATE,
    deleted_status VARCHAR(20),
    deletion_timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    deleted_by_user VARCHAR(50) DEFAULT USER()
);

-- Create BEFORE DELETE trigger
DELIMITER $$

CREATE TRIGGER before_order_delete
BEFORE DELETE ON `Order`
FOR EACH ROW
BEGIN
    -- Insert deleted record details into audit table
    INSERT INTO Order_Delete_Audit 
    (deleted_order_id, deleted_cust_id, deleted_product_type, 
     deleted_amtpaid, deleted_date, deleted_status)
    VALUES 
    (OLD.order_id, OLD.cust_id, OLD.product_type, 
     OLD.amtpaid, OLD.delivery_date, OLD.status);
     
    -- Optional: Log message (for debugging)
    -- INSERT INTO system_log (message) 
    -- VALUES (CONCAT('Order ', OLD.order_id, ' deleted by ', USER()));
END$$

DELIMITER ;

-- Test the trigger by deleting an order
-- First, check current orders
SELECT * FROM `Order`;

-- Delete an order (this will trigger the audit)
DELETE FROM `Order` WHERE order_id = 7;

-- Check the audit table
SELECT * FROM Order_Delete_Audit;

-- Additional: Create an AFTER DELETE trigger for customer notification
DELIMITER $$

CREATE TRIGGER after_order_delete
AFTER DELETE ON `Order`
FOR EACH ROW
BEGIN
    -- Update customer order count (if you have such a column)
    -- UPDATE Customer 
    -- SET total_orders = total_orders - 1 
    -- WHERE cust_id = OLD.cust_id;
    
    -- Or insert into notification table
    INSERT INTO Customer_Notifications 
    (cust_id, message, notification_date)
    VALUES 
    (OLD.cust_id, 
     CONCAT('Your order #', OLD.order_id, ' has been deleted from our system.'),
     CURDATE());
END$$

DELIMITER ;

-- Create the notification table if needed
CREATE TABLE Customer_Notifications (
    notification_id INT PRIMARY KEY AUTO_INCREMENT,
    cust_id INT,
    message TEXT,
    notification_date DATE,
    is_read BOOLEAN DEFAULT FALSE,
    FOREIGN KEY (cust_id) REFERENCES Customer(cust_id)
);
```

d. Display cust_ids of those who haven't placed any order

```sql
-- Solution 1: Using LEFT JOIN with IS NULL check
SELECT 
    c.cust_id,
    c.cust_name,
    c.email,
    c.city,
    c.state
FROM Customer c
LEFT JOIN `Order` o ON c.cust_id = o.cust_id
WHERE o.order_id IS NULL
ORDER BY c.cust_id;

-- Solution 2: Using NOT IN subquery
SELECT 
    cust_id,
    cust_name,
    email,
    city,
    state
FROM Customer
WHERE cust_id NOT IN (SELECT DISTINCT cust_id FROM `Order`)
ORDER BY cust_id;

-- Solution 3: Using NOT EXISTS (most efficient for large datasets)
SELECT 
    c.cust_id,
    c.cust_name,
    c.email,
    c.city,
    c.state
FROM Customer c
WHERE NOT EXISTS (
    SELECT 1 
    FROM `Order` o 
    WHERE o.cust_id = c.cust_id
)
ORDER BY c.cust_id;

-- Solution 4: With COUNT of orders
SELECT 
    c.cust_id,
    c.cust_name,
    c.email,
    c.city,
    c.state,
    COUNT(o.order_id) AS order_count
FROM Customer c
LEFT JOIN `Order` o ON c.cust_id = o.cust_id
GROUP BY c.cust_id, c.cust_name, c.email, c.city, c.state
HAVING COUNT(o.order_id) = 0
ORDER BY c.cust_id;

-- Expected output:
-- +---------+-------------+----------------+---------+------------+
-- | cust_id | cust_name   | email          | city    | state      |
-- +---------+-------------+----------------+---------+------------+
-- |       5 | Mike Wilson | mike@email.com | Chennai | Tamil Nadu |
-- |       6 | Sarah Brown | sarah@email.com| Delhi   | Delhi      |
-- |       7 | David Lee   | david@email.com| Pune    | Maharashtra|
-- +---------+-------------+----------------+---------+------------+
```

3. Additional Useful Queries

View all data with relationships

```sql
-- View all customers with their orders
SELECT 
    c.cust_id,
    c.cust_name,
    c.city,
    c.state,
    o.order_id,
    o.product_type,
    o.amtpaid,
    o.status,
    o.delivery_date
FROM Customer c
LEFT JOIN `Order` o ON c.cust_id = o.cust_id
ORDER BY c.cust_id, o.order_id;
```

Order statistics by customer

```sql
-- Detailed order statistics per customer
SELECT 
    c.cust_id,
    c.cust_name,
    c.state,
    COUNT(o.order_id) AS total_orders,
    SUM(CASE WHEN o.status = 'Delivered' THEN 1 ELSE 0 END) AS delivered_orders,
    SUM(CASE WHEN o.status = 'Processing' THEN 1 ELSE 0 END) AS processing_orders,
    SUM(CASE WHEN o.status = 'Shipped' THEN 1 ELSE 0 END) AS shipped_orders,
    SUM(CASE WHEN o.status = 'Cancelled' THEN 1 ELSE 0 END) AS cancelled_orders,
    COALESCE(SUM(o.amtpaid), 0) AS total_spent,
    COALESCE(MIN(o.delivery_date), 'No orders') AS first_order_date,
    COALESCE(MAX(o.delivery_date), 'No orders') AS last_order_date
FROM Customer c
LEFT JOIN `Order` o ON c.cust_id = o.cust_id
GROUP BY c.cust_id, c.cust_name, c.state
ORDER BY total_spent DESC;
```

Delete all test data and start fresh

```sql
-- Clean up (if needed)
DROP TRIGGER IF EXISTS before_order_delete;
DROP TRIGGER IF EXISTS after_order_delete;
DROP TABLE IF EXISTS Order_Delete_Audit;
DROP TABLE IF EXISTS Customer_Notifications;
DROP TABLE IF EXISTS `Order`;
DROP TABLE IF EXISTS Customer;
DROP DATABASE IF EXISTS customer_order_db;
```

4. Summary of Solutions

a. Add 'state' column:

· Used ALTER TABLE to add new column
· Used UPDATE to populate data based on city

b. Total amount paid by each customer:

· Used LEFT JOIN to include customers with no orders
· Used COALESCE() to display 0 instead of NULL
· Used GROUP BY and SUM() aggregation

c. Delete trigger on Order table:

· Created audit table to track deletions
· Created BEFORE DELETE trigger to log deleted orders
· Optional: Created AFTER DELETE trigger for notifications

d. Customers without orders:

· Three different approaches demonstrated:
  1. LEFT JOIN with IS NULL check
  2. NOT IN subquery
  3. NOT EXISTS subquery (most efficient)
· All correctly identify customers 5, 6, and 7

Key Learning Points:

1. ALTER TABLE is used to modify table structure
2. LEFT JOIN vs INNER JOIN - important for including/excluding null matches
3. Triggers execute automatically on specified events (INSERT, UPDATE, DELETE)
4. Aggregate functions (SUM, COUNT) with GROUP BY for calculations
5. Subqueries provide alternative solutions to JOIN operations
6. COALESCE() handles NULL values gracefully
7. Foreign keys maintain referential integrity between tables
